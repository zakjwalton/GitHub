
EGR 326 - Final Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000032  00800100  00000c64  00000cf8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000c64  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800132  00800132  00000d2a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d2a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000218  00000000  00000000  00000d5a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001e36  00000000  00000000  00000f72  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000811  00000000  00000000  00002da8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000a5d  00000000  00000000  000035b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000005f0  00000000  00000000  00004018  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000750  00000000  00000000  00004608  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001787  00000000  00000000  00004d58  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001a8  00000000  00000000  000064df  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 */ 
#include "FSM.h"
#include "Buttons.h"

state_t determine_state(state_t state, int button_pressed)
{
   0:	0c 94 33 01 	jmp	0x266	; 0x266 <__ctors_end>
   4:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
	uint8_t temp_state;
	
	if(button_pressed == BACK_BUTTON)
   8:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
		}
		else if(button_pressed == SETTING_BUTTON)
			{
			// do nothing for now
			}
			else if(button_pressed == FORWARD_BUTTON)
   c:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  10:	0c 94 60 01 	jmp	0x2c0	; 0x2c0 <__vector_4>
	
	if(button_pressed == BACK_BUTTON)
		{
			temp_state = state.current;
			state.current = state.previous;
			state.previous = temp_state;
  14:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
	uint8_t temp_state;
	
	if(button_pressed == BACK_BUTTON)
		{
			temp_state = state.current;
			state.current = state.previous;
  18:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
			}
			else if(button_pressed == FORWARD_BUTTON)
				{
			     temp_state = state.current;
				 state.current = state.next;
				 state.next = temp_state;
  1c:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  20:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  24:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  28:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  2c:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  30:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  34:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  38:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  3c:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  40:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  44:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  48:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  4c:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  50:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  54:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  58:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  5c:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  60:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>
  64:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	3e 41       	sbci	r19, 0x1E	; 30
  6a:	41 41       	sbci	r20, 0x11	; 17
  6c:	3e 00       	.word	0x003e	; ????
  6e:	42 7f       	andi	r20, 0xF2	; 242
  70:	40 00       	.word	0x0040	; ????
  72:	42 61       	ori	r20, 0x12	; 18
  74:	51 49       	sbci	r21, 0x91	; 145
  76:	46 21       	and	r20, r6
  78:	41 45       	sbci	r20, 0x51	; 81
  7a:	4b 31       	cpi	r20, 0x1B	; 27
  7c:	18 14       	cp	r1, r8
  7e:	12 7f       	andi	r17, 0xF2	; 242
  80:	10 27       	eor	r17, r16
  82:	45 45       	sbci	r20, 0x55	; 85
  84:	45 39       	cpi	r20, 0x95	; 149
  86:	3c 4a       	sbci	r19, 0xAC	; 172
  88:	49 49       	sbci	r20, 0x99	; 153
  8a:	30 01       	movw	r6, r0
  8c:	71 09       	sbc	r23, r1
  8e:	05 03       	mulsu	r16, r21
  90:	36 49       	sbci	r19, 0x96	; 150
  92:	49 49       	sbci	r20, 0x99	; 153
  94:	36 06       	cpc	r3, r22
  96:	49 49       	sbci	r20, 0x99	; 153
  98:	29 1e       	adc	r2, r25

0000009a <smallFont>:
  9a:	00 00 00 00 00 00 00 2f 00 00 00 07 00 07 00 14     ......./........
  aa:	7f 14 7f 14 24 2a 7f 2a 12 c4 c8 10 26 46 36 49     ....$*.*....&F6I
  ba:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
  ca:	1c 00 14 08 3e 08 14 08 08 3e 08 08 00 00 50 30     ....>....>....P0
  da:	00 10 10 10 10 10 00 60 60 00 00 20 10 08 04 02     .......``.. ....
  ea:	3e 41 41 41 3e 00 42 7f 40 00 42 61 51 49 46 21     >AAA>.B.@.BaQIF!
  fa:	41 45 4b 31 18 14 12 7f 10 27 45 45 45 39 3c 4a     AEK1.....'EEE9<J
 10a:	49 49 30 01 71 09 05 03 36 49 49 49 36 06 49 49     II0.q...6III6.II
 11a:	29 1e 00 36 36 00 00 00 56 36 00 00 08 14 22 41     )..66...V6...."A
 12a:	00 14 14 14 14 14 00 41 22 14 08 02 01 51 09 06     .......A"....Q..
 13a:	32 49 59 51 3e 7e 11 11 11 7e 7f 49 49 49 36 3e     2IYQ>~...~.III6>
 14a:	41 41 41 22 7f 41 41 22 1c 7f 49 49 49 41 7f 09     AAA".AA"..IIIA..
 15a:	09 09 01 3e 41 49 49 7a 7f 08 08 08 7f 00 41 7f     ...>AIIz......A.
 16a:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
 17a:	40 7f 02 0c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
 18a:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 46     .....>AQ!^...)FF
 19a:	49 49 49 31 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III1.....?@@@?. 
 1aa:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 07 08 70     @ .?@8@?c...c..p
 1ba:	08 07 61 51 49 45 43 00 7f 41 41 00 55 2a 55 2a     ..aQIEC..AA.U*U*
 1ca:	55 00 41 41 7f 00 04 02 01 02 04 40 40 40 40 40     U.AA.......@@@@@
 1da:	00 01 02 04 00 20 54 54 54 78 7f 48 44 44 38 38     ..... TTTx.HDD88
 1ea:	44 44 44 20 38 44 44 48 7f 38 54 54 54 18 08 7e     DDD 8DDH.8TTT..~
 1fa:	09 01 02 0c 52 52 52 3e 7f 08 04 04 78 00 44 7d     ....RRR>....x.D}
 20a:	40 00 20 40 44 3d 00 7f 10 28 44 00 00 41 7f 40     @. @D=...(D..A.@
 21a:	00 7c 04 18 04 78 7c 08 04 04 78 38 44 44 44 38     .|...x|...x8DDD8
 22a:	7c 14 14 14 08 08 14 14 18 7c 7c 08 04 04 08 48     |........||....H
 23a:	54 54 54 20 04 3f 44 40 20 3c 40 40 20 7c 1c 20     TTT .?D@ <@@ |. 
 24a:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 0c 50 50     @ .<@0@<D(.(D.PP
 25a:	50 3c 44 64 54 4c 44 00 06 09 09 06                 P<DdTLD.....

00000266 <__ctors_end>:
 266:	11 24       	eor	r1, r1
 268:	1f be       	out	0x3f, r1	; 63
 26a:	cf ef       	ldi	r28, 0xFF	; 255
 26c:	d8 e0       	ldi	r29, 0x08	; 8
 26e:	de bf       	out	0x3e, r29	; 62
 270:	cd bf       	out	0x3d, r28	; 61

00000272 <__do_copy_data>:
 272:	11 e0       	ldi	r17, 0x01	; 1
 274:	a0 e0       	ldi	r26, 0x00	; 0
 276:	b1 e0       	ldi	r27, 0x01	; 1
 278:	e4 e6       	ldi	r30, 0x64	; 100
 27a:	fc e0       	ldi	r31, 0x0C	; 12
 27c:	02 c0       	rjmp	.+4      	; 0x282 <__do_copy_data+0x10>
 27e:	05 90       	lpm	r0, Z+
 280:	0d 92       	st	X+, r0
 282:	a2 33       	cpi	r26, 0x32	; 50
 284:	b1 07       	cpc	r27, r17
 286:	d9 f7       	brne	.-10     	; 0x27e <__do_copy_data+0xc>

00000288 <__do_clear_bss>:
 288:	21 e0       	ldi	r18, 0x01	; 1
 28a:	a2 e3       	ldi	r26, 0x32	; 50
 28c:	b1 e0       	ldi	r27, 0x01	; 1
 28e:	01 c0       	rjmp	.+2      	; 0x292 <.do_clear_bss_start>

00000290 <.do_clear_bss_loop>:
 290:	1d 92       	st	X+, r1

00000292 <.do_clear_bss_start>:
 292:	a4 33       	cpi	r26, 0x34	; 52
 294:	b2 07       	cpc	r27, r18
 296:	e1 f7       	brne	.-8      	; 0x290 <.do_clear_bss_loop>
 298:	0e 94 a8 01 	call	0x350	; 0x350 <main>
 29c:	0c 94 30 06 	jmp	0xc60	; 0xc60 <_exit>

000002a0 <__bad_interrupt>:
 2a0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000002a4 <BUTTON_init>:
// Setting data direction for buttons as inputs (already set to zero)

// Setting pins that buttons are attached to as input capture pins (generates an input when any of the three pins are pressed)

// Enabling internal pull-up resistor on pins attached to buttons
BUTTON_1_PORT |= _BV(BUTTON_1_PIN);     
 2a4:	30 9a       	sbi	0x06, 0	; 6
BUTTON_2_PORT |= _BV(BUTTON_2_PIN);
 2a6:	31 9a       	sbi	0x06, 1	; 6
BUTTON_3_PORT |= _BV(BUTTON_3_PIN);
 2a8:	32 9a       	sbi	0x06, 2	; 6

// Enabling Pin change interrupts on pins PC0-PC7
PCICR |= _BV(PCIE1);
 2aa:	e8 e6       	ldi	r30, 0x68	; 104
 2ac:	f0 e0       	ldi	r31, 0x00	; 0
 2ae:	80 81       	ld	r24, Z
 2b0:	82 60       	ori	r24, 0x02	; 2
 2b2:	80 83       	st	Z, r24

// Enabling the three buttons used for the alarm clock
PCMSK1 |= _BV(PCINT10) | _BV(PCINT9) | _BV(PCINT8);
 2b4:	ec e6       	ldi	r30, 0x6C	; 108
 2b6:	f0 e0       	ldi	r31, 0x00	; 0
 2b8:	80 81       	ld	r24, Z
 2ba:	87 60       	ori	r24, 0x07	; 7
 2bc:	80 83       	st	Z, r24
 2be:	08 95       	ret

000002c0 <__vector_4>:
int g_button_pressed=0;



ISR(PCINT1_vect)
{
 2c0:	1f 92       	push	r1
 2c2:	0f 92       	push	r0
 2c4:	0f b6       	in	r0, 0x3f	; 63
 2c6:	0f 92       	push	r0
 2c8:	11 24       	eor	r1, r1
 2ca:	2f 93       	push	r18
 2cc:	3f 93       	push	r19
 2ce:	4f 93       	push	r20
 2d0:	5f 93       	push	r21
 2d2:	6f 93       	push	r22
 2d4:	7f 93       	push	r23
 2d6:	8f 93       	push	r24
 2d8:	9f 93       	push	r25
 2da:	af 93       	push	r26
 2dc:	bf 93       	push	r27
 2de:	ef 93       	push	r30
 2e0:	ff 93       	push	r31
	if(!(PINC & _BV(BUTTON_1))){
 2e2:	30 99       	sbic	0x06, 0	; 6
 2e4:	0b c0       	rjmp	.+22     	; 0x2fc <__vector_4+0x3c>
		g_button_pressed = B1;
 2e6:	81 e0       	ldi	r24, 0x01	; 1
 2e8:	90 e0       	ldi	r25, 0x00	; 0
 2ea:	90 93 33 01 	sts	0x0133, r25
 2ee:	80 93 32 01 	sts	0x0132, r24
		hw_delay(200);
 2f2:	88 ec       	ldi	r24, 0xC8	; 200
 2f4:	90 e0       	ldi	r25, 0x00	; 0
 2f6:	0e 94 ee 05 	call	0xbdc	; 0xbdc <hw_delay>
 2fa:	19 c0       	rjmp	.+50     	; 0x32e <__vector_4+0x6e>
	}
	else if(!(PINC & _BV(BUTTON_2))){
 2fc:	31 99       	sbic	0x06, 1	; 6
 2fe:	0b c0       	rjmp	.+22     	; 0x316 <__vector_4+0x56>
		g_button_pressed = B2;
 300:	82 e0       	ldi	r24, 0x02	; 2
 302:	90 e0       	ldi	r25, 0x00	; 0
 304:	90 93 33 01 	sts	0x0133, r25
 308:	80 93 32 01 	sts	0x0132, r24
		hw_delay(200);
 30c:	88 ec       	ldi	r24, 0xC8	; 200
 30e:	90 e0       	ldi	r25, 0x00	; 0
 310:	0e 94 ee 05 	call	0xbdc	; 0xbdc <hw_delay>
 314:	0c c0       	rjmp	.+24     	; 0x32e <__vector_4+0x6e>
	}
	else if (!(PINC & _BV(BUTTON_3))){
 316:	32 99       	sbic	0x06, 2	; 6
 318:	0a c0       	rjmp	.+20     	; 0x32e <__vector_4+0x6e>
		g_button_pressed = B3;
 31a:	83 e0       	ldi	r24, 0x03	; 3
 31c:	90 e0       	ldi	r25, 0x00	; 0
 31e:	90 93 33 01 	sts	0x0133, r25
 322:	80 93 32 01 	sts	0x0132, r24
		hw_delay(200);
 326:	88 ec       	ldi	r24, 0xC8	; 200
 328:	90 e0       	ldi	r25, 0x00	; 0
 32a:	0e 94 ee 05 	call	0xbdc	; 0xbdc <hw_delay>
	}
}
 32e:	ff 91       	pop	r31
 330:	ef 91       	pop	r30
 332:	bf 91       	pop	r27
 334:	af 91       	pop	r26
 336:	9f 91       	pop	r25
 338:	8f 91       	pop	r24
 33a:	7f 91       	pop	r23
 33c:	6f 91       	pop	r22
 33e:	5f 91       	pop	r21
 340:	4f 91       	pop	r20
 342:	3f 91       	pop	r19
 344:	2f 91       	pop	r18
 346:	0f 90       	pop	r0
 348:	0f be       	out	0x3f, r0	; 63
 34a:	0f 90       	pop	r0
 34c:	1f 90       	pop	r1
 34e:	18 95       	reti

00000350 <main>:


int main(void)
{
 350:	cf 93       	push	r28
 352:	df 93       	push	r29
 354:	cd b7       	in	r28, 0x3d	; 61
 356:	de b7       	in	r29, 0x3e	; 62
 358:	a2 97       	sbiw	r28, 0x22	; 34
 35a:	0f b6       	in	r0, 0x3f	; 63
 35c:	f8 94       	cli
 35e:	de bf       	out	0x3e, r29	; 62
 360:	0f be       	out	0x3f, r0	; 63
 362:	cd bf       	out	0x3d, r28	; 61
	cli();
 364:	f8 94       	cli
	//initialize I2C, timers and button
	//Timer0_Init();
	Timer1_Init();
 366:	0e 94 da 05 	call	0xbb4	; 0xbb4 <Timer1_Init>
	Timer2_Init();
 36a:	0e 94 d1 05 	call	0xba2	; 0xba2 <Timer2_Init>
	I2C_Init();
 36e:	0e 94 c1 02 	call	0x582	; 0x582 <I2C_Init>
	BUTTON_init();
 372:	0e 94 52 01 	call	0x2a4	; 0x2a4 <BUTTON_init>
	LCD_SPI_initialize();
 376:	0e 94 24 03 	call	0x648	; 0x648 <LCD_SPI_initialize>
	LCD_initialize();
 37a:	0e 94 5d 03 	call	0x6ba	; 0x6ba <LCD_initialize>
	sei();
 37e:	78 94       	sei
	
	time_t time;
	time_t alarmtime;
	char alarm_onoff[10];
	char on[] = "ON ";
 380:	8f e4       	ldi	r24, 0x4F	; 79
 382:	9e e4       	ldi	r25, 0x4E	; 78
 384:	a0 e2       	ldi	r26, 0x20	; 32
 386:	b0 e0       	ldi	r27, 0x00	; 0
 388:	8b 8f       	std	Y+27, r24	; 0x1b
 38a:	9c 8f       	std	Y+28, r25	; 0x1c
 38c:	ad 8f       	std	Y+29, r26	; 0x1d
 38e:	be 8f       	std	Y+30, r27	; 0x1e
	char off[] = "OFF";
 390:	8f e4       	ldi	r24, 0x4F	; 79
 392:	96 e4       	ldi	r25, 0x46	; 70
 394:	a6 e4       	ldi	r26, 0x46	; 70
 396:	b0 e0       	ldi	r27, 0x00	; 0
 398:	8f 8f       	std	Y+31, r24	; 0x1f
 39a:	98 a3       	std	Y+32, r25	; 0x20
 39c:	a9 a3       	std	Y+33, r26	; 0x21
 39e:	ba a3       	std	Y+34, r27	; 0x22
	int alarmOnOff = 0;
	
	strcpy(alarm_onoff,on);
 3a0:	be 01       	movw	r22, r28
 3a2:	65 5e       	subi	r22, 0xE5	; 229
 3a4:	7f 4f       	sbci	r23, 0xFF	; 255
 3a6:	ce 01       	movw	r24, r28
 3a8:	41 96       	adiw	r24, 0x11	; 17
 3aa:	0e 94 29 06 	call	0xc52	; 0xc52 <strcpy>
	
	time.minute = 23;
 3ae:	87 e1       	ldi	r24, 0x17	; 23
 3b0:	8e 83       	std	Y+6, r24	; 0x06
	time.hour = 9;
 3b2:	89 e0       	ldi	r24, 0x09	; 9
 3b4:	8d 83       	std	Y+5, r24	; 0x05
	time.second =11;
 3b6:	8b e0       	ldi	r24, 0x0B	; 11
 3b8:	8f 83       	std	Y+7, r24	; 0x07
	
	alarmtime.minute = 23;
	alarmtime.hour = 11;
	alarmtime.second = 10;
 3ba:	8a e0       	ldi	r24, 0x0A	; 10
 3bc:	8f 87       	std	Y+15, r24	; 0x0f
	
	RTC_Set(time);
 3be:	29 81       	ldd	r18, Y+1	; 0x01
 3c0:	3a 81       	ldd	r19, Y+2	; 0x02
 3c2:	4b 81       	ldd	r20, Y+3	; 0x03
 3c4:	5c 81       	ldd	r21, Y+4	; 0x04
 3c6:	69 e0       	ldi	r22, 0x09	; 9
 3c8:	77 e1       	ldi	r23, 0x17	; 23
 3ca:	8b e0       	ldi	r24, 0x0B	; 11
 3cc:	98 85       	ldd	r25, Y+8	; 0x08
 3ce:	0e 94 47 05 	call	0xa8e	; 0xa8e <RTC_Set>
	
	time.minute = 23;
	time.hour = 9;
	time.second =11;
	
	alarmtime.minute = 23;
 3d2:	0f 2e       	mov	r0, r31
 3d4:	f7 e1       	ldi	r31, 0x17	; 23
 3d6:	6f 2e       	mov	r6, r31
 3d8:	f0 2d       	mov	r31, r0
	alarmtime.hour = 11;
 3da:	0f 2e       	mov	r0, r31
 3dc:	fb e0       	ldi	r31, 0x0B	; 11
 3de:	7f 2e       	mov	r7, r31
 3e0:	f0 2d       	mov	r31, r0
	time_t time;
	time_t alarmtime;
	char alarm_onoff[10];
	char on[] = "ON ";
	char off[] = "OFF";
	int alarmOnOff = 0;
 3e2:	81 2c       	mov	r8, r1
 3e4:	91 2c       	mov	r9, r1
					hw_delay(5);
					if(g_button_pressed == B1)
					{
						alarmtime.minute++;
						if(alarmtime.minute == 60){
							alarmtime.minute = 0;
 3e6:	51 2c       	mov	r5, r1
	
	RTC_Set(time);
	while(1)
	{
		
		RTC_Read(&time);
 3e8:	ce 01       	movw	r24, r28
 3ea:	01 96       	adiw	r24, 0x01	; 1
 3ec:	0e 94 99 05 	call	0xb32	; 0xb32 <RTC_Read>
		LCD_print_time_display(time, 21,"SET", "ALARM", alarm_onoff);
 3f0:	ce 01       	movw	r24, r28
 3f2:	41 96       	adiw	r24, 0x11	; 17
 3f4:	5c 01       	movw	r10, r24
 3f6:	0f 2e       	mov	r0, r31
 3f8:	f0 e0       	ldi	r31, 0x00	; 0
 3fa:	cf 2e       	mov	r12, r31
 3fc:	f1 e0       	ldi	r31, 0x01	; 1
 3fe:	df 2e       	mov	r13, r31
 400:	f0 2d       	mov	r31, r0
 402:	0f 2e       	mov	r0, r31
 404:	f6 e0       	ldi	r31, 0x06	; 6
 406:	ef 2e       	mov	r14, r31
 408:	f1 e0       	ldi	r31, 0x01	; 1
 40a:	ff 2e       	mov	r15, r31
 40c:	f0 2d       	mov	r31, r0
 40e:	05 e1       	ldi	r16, 0x15	; 21
 410:	10 e0       	ldi	r17, 0x00	; 0
 412:	29 81       	ldd	r18, Y+1	; 0x01
 414:	3a 81       	ldd	r19, Y+2	; 0x02
 416:	4b 81       	ldd	r20, Y+3	; 0x03
 418:	5c 81       	ldd	r21, Y+4	; 0x04
 41a:	6d 81       	ldd	r22, Y+5	; 0x05
 41c:	7e 81       	ldd	r23, Y+6	; 0x06
 41e:	8f 81       	ldd	r24, Y+7	; 0x07
 420:	98 85       	ldd	r25, Y+8	; 0x08
 422:	0e 94 70 04 	call	0x8e0	; 0x8e0 <LCD_print_time_display>
	
		
		switch (g_button_pressed){
 426:	80 91 32 01 	lds	r24, 0x0132
 42a:	90 91 33 01 	lds	r25, 0x0133
 42e:	82 30       	cpi	r24, 0x02	; 2
 430:	91 05       	cpc	r25, r1
 432:	21 f0       	breq	.+8      	; 0x43c <main+0xec>
 434:	03 97       	sbiw	r24, 0x03	; 3
 436:	09 f4       	brne	.+2      	; 0x43a <main+0xea>
 438:	8b c0       	rjmp	.+278    	; 0x550 <main+0x200>
 43a:	d6 cf       	rjmp	.-84     	; 0x3e8 <main+0x98>
			case (B1):
				break;
			case (B2):
				LCD_print_alarm_display(alarmtime,"UP","ENTER"," ");
 43c:	0f 2e       	mov	r0, r31
 43e:	f3 e2       	ldi	r31, 0x23	; 35
 440:	cf 2e       	mov	r12, r31
 442:	f1 e0       	ldi	r31, 0x01	; 1
 444:	df 2e       	mov	r13, r31
 446:	f0 2d       	mov	r31, r0
 448:	0f 2e       	mov	r0, r31
 44a:	fa e0       	ldi	r31, 0x0A	; 10
 44c:	ef 2e       	mov	r14, r31
 44e:	f1 e0       	ldi	r31, 0x01	; 1
 450:	ff 2e       	mov	r15, r31
 452:	f0 2d       	mov	r31, r0
 454:	00 e1       	ldi	r16, 0x10	; 16
 456:	11 e0       	ldi	r17, 0x01	; 1
 458:	29 85       	ldd	r18, Y+9	; 0x09
 45a:	3a 85       	ldd	r19, Y+10	; 0x0a
 45c:	4b 85       	ldd	r20, Y+11	; 0x0b
 45e:	5c 85       	ldd	r21, Y+12	; 0x0c
 460:	67 2d       	mov	r22, r7
 462:	76 2d       	mov	r23, r6
 464:	8f 85       	ldd	r24, Y+15	; 0x0f
 466:	98 89       	ldd	r25, Y+16	; 0x10
 468:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <LCD_print_alarm_display>
				CLEAR_BUTTONS;
 46c:	10 92 33 01 	sts	0x0133, r1
 470:	10 92 32 01 	sts	0x0132, r1
				while(g_button_pressed != B2)
 474:	2b c0       	rjmp	.+86     	; 0x4cc <main+0x17c>
				{
					hw_delay(5);
 476:	85 e0       	ldi	r24, 0x05	; 5
 478:	90 e0       	ldi	r25, 0x00	; 0
 47a:	0e 94 ee 05 	call	0xbdc	; 0xbdc <hw_delay>
					if(g_button_pressed == B1)
 47e:	80 91 32 01 	lds	r24, 0x0132
 482:	90 91 33 01 	lds	r25, 0x0133
 486:	01 97       	sbiw	r24, 0x01	; 1
 488:	09 f5       	brne	.+66     	; 0x4cc <main+0x17c>
					{
						alarmtime.hour++;
 48a:	73 94       	inc	r7
						if(alarmtime.hour == 24){
 48c:	98 e1       	ldi	r25, 0x18	; 24
 48e:	79 12       	cpse	r7, r25
 490:	01 c0       	rjmp	.+2      	; 0x494 <main+0x144>
							alarmtime.hour = 0;
 492:	75 2c       	mov	r7, r5
						}
						LCD_print_alarm_display(alarmtime,"UP","ENTER"," ");
 494:	0f 2e       	mov	r0, r31
 496:	f3 e2       	ldi	r31, 0x23	; 35
 498:	cf 2e       	mov	r12, r31
 49a:	f1 e0       	ldi	r31, 0x01	; 1
 49c:	df 2e       	mov	r13, r31
 49e:	f0 2d       	mov	r31, r0
 4a0:	0f 2e       	mov	r0, r31
 4a2:	fa e0       	ldi	r31, 0x0A	; 10
 4a4:	ef 2e       	mov	r14, r31
 4a6:	f1 e0       	ldi	r31, 0x01	; 1
 4a8:	ff 2e       	mov	r15, r31
 4aa:	f0 2d       	mov	r31, r0
 4ac:	00 e1       	ldi	r16, 0x10	; 16
 4ae:	11 e0       	ldi	r17, 0x01	; 1
 4b0:	29 85       	ldd	r18, Y+9	; 0x09
 4b2:	3a 85       	ldd	r19, Y+10	; 0x0a
 4b4:	4b 85       	ldd	r20, Y+11	; 0x0b
 4b6:	5c 85       	ldd	r21, Y+12	; 0x0c
 4b8:	67 2d       	mov	r22, r7
 4ba:	76 2d       	mov	r23, r6
 4bc:	8f 85       	ldd	r24, Y+15	; 0x0f
 4be:	98 89       	ldd	r25, Y+16	; 0x10
 4c0:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <LCD_print_alarm_display>
						CLEAR_BUTTONS;
 4c4:	10 92 33 01 	sts	0x0133, r1
 4c8:	10 92 32 01 	sts	0x0132, r1
			case (B1):
				break;
			case (B2):
				LCD_print_alarm_display(alarmtime,"UP","ENTER"," ");
				CLEAR_BUTTONS;
				while(g_button_pressed != B2)
 4cc:	80 91 32 01 	lds	r24, 0x0132
 4d0:	90 91 33 01 	lds	r25, 0x0133
 4d4:	02 97       	sbiw	r24, 0x02	; 2
 4d6:	79 f6       	brne	.-98     	; 0x476 <main+0x126>
 4d8:	b7 2c       	mov	r11, r7
						}
						LCD_print_alarm_display(alarmtime,"UP","ENTER"," ");
						CLEAR_BUTTONS;
					}
				}
				CLEAR_BUTTONS;
 4da:	10 92 33 01 	sts	0x0133, r1
 4de:	10 92 32 01 	sts	0x0132, r1
				while(g_button_pressed != B2)
 4e2:	2b c0       	rjmp	.+86     	; 0x53a <main+0x1ea>
				{
					hw_delay(5);
 4e4:	85 e0       	ldi	r24, 0x05	; 5
 4e6:	90 e0       	ldi	r25, 0x00	; 0
 4e8:	0e 94 ee 05 	call	0xbdc	; 0xbdc <hw_delay>
					if(g_button_pressed == B1)
 4ec:	80 91 32 01 	lds	r24, 0x0132
 4f0:	90 91 33 01 	lds	r25, 0x0133
 4f4:	01 97       	sbiw	r24, 0x01	; 1
 4f6:	09 f5       	brne	.+66     	; 0x53a <main+0x1ea>
					{
						alarmtime.minute++;
 4f8:	63 94       	inc	r6
						if(alarmtime.minute == 60){
 4fa:	8c e3       	ldi	r24, 0x3C	; 60
 4fc:	68 12       	cpse	r6, r24
 4fe:	01 c0       	rjmp	.+2      	; 0x502 <main+0x1b2>
							alarmtime.minute = 0;
 500:	65 2c       	mov	r6, r5
						}
						LCD_print_alarm_display(alarmtime,"UP","ENTER"," ");
 502:	0f 2e       	mov	r0, r31
 504:	f3 e2       	ldi	r31, 0x23	; 35
 506:	cf 2e       	mov	r12, r31
 508:	f1 e0       	ldi	r31, 0x01	; 1
 50a:	df 2e       	mov	r13, r31
 50c:	f0 2d       	mov	r31, r0
 50e:	0f 2e       	mov	r0, r31
 510:	fa e0       	ldi	r31, 0x0A	; 10
 512:	ef 2e       	mov	r14, r31
 514:	f1 e0       	ldi	r31, 0x01	; 1
 516:	ff 2e       	mov	r15, r31
 518:	f0 2d       	mov	r31, r0
 51a:	00 e1       	ldi	r16, 0x10	; 16
 51c:	11 e0       	ldi	r17, 0x01	; 1
 51e:	29 85       	ldd	r18, Y+9	; 0x09
 520:	3a 85       	ldd	r19, Y+10	; 0x0a
 522:	4b 85       	ldd	r20, Y+11	; 0x0b
 524:	5c 85       	ldd	r21, Y+12	; 0x0c
 526:	6b 2d       	mov	r22, r11
 528:	76 2d       	mov	r23, r6
 52a:	8f 85       	ldd	r24, Y+15	; 0x0f
 52c:	98 89       	ldd	r25, Y+16	; 0x10
 52e:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <LCD_print_alarm_display>
						CLEAR_BUTTONS;
 532:	10 92 33 01 	sts	0x0133, r1
 536:	10 92 32 01 	sts	0x0132, r1
						LCD_print_alarm_display(alarmtime,"UP","ENTER"," ");
						CLEAR_BUTTONS;
					}
				}
				CLEAR_BUTTONS;
				while(g_button_pressed != B2)
 53a:	80 91 32 01 	lds	r24, 0x0132
 53e:	90 91 33 01 	lds	r25, 0x0133
 542:	02 97       	sbiw	r24, 0x02	; 2
 544:	79 f6       	brne	.-98     	; 0x4e4 <main+0x194>
						}
						LCD_print_alarm_display(alarmtime,"UP","ENTER"," ");
						CLEAR_BUTTONS;
					}
				}
				CLEAR_BUTTONS;
 546:	10 92 33 01 	sts	0x0133, r1
 54a:	10 92 32 01 	sts	0x0132, r1
				break;
 54e:	4c cf       	rjmp	.-360    	; 0x3e8 <main+0x98>
			case (B3):
				alarmOnOff ^= 0x01;
 550:	91 e0       	ldi	r25, 0x01	; 1
 552:	89 26       	eor	r8, r25
				if(alarmOnOff){
 554:	81 14       	cp	r8, r1
 556:	91 04       	cpc	r9, r1
 558:	41 f0       	breq	.+16     	; 0x56a <main+0x21a>
					strcpy(alarm_onoff,on);
 55a:	be 01       	movw	r22, r28
 55c:	65 5e       	subi	r22, 0xE5	; 229
 55e:	7f 4f       	sbci	r23, 0xFF	; 255
 560:	ce 01       	movw	r24, r28
 562:	41 96       	adiw	r24, 0x11	; 17
 564:	0e 94 29 06 	call	0xc52	; 0xc52 <strcpy>
 568:	07 c0       	rjmp	.+14     	; 0x578 <main+0x228>
				}
				else{
					strcpy(alarm_onoff,off);
 56a:	be 01       	movw	r22, r28
 56c:	61 5e       	subi	r22, 0xE1	; 225
 56e:	7f 4f       	sbci	r23, 0xFF	; 255
 570:	ce 01       	movw	r24, r28
 572:	41 96       	adiw	r24, 0x11	; 17
 574:	0e 94 29 06 	call	0xc52	; 0xc52 <strcpy>
				}
				CLEAR_BUTTONS;
 578:	10 92 33 01 	sts	0x0133, r1
 57c:	10 92 32 01 	sts	0x0132, r1
				break;
 580:	33 cf       	rjmp	.-410    	; 0x3e8 <main+0x98>

00000582 <I2C_Init>:
*************************************************/

void I2C_Init(void){
	
	//set PC5 and PC6 as output pins
	DDRC |= _BV(PC5) | _BV(PC6);
 582:	87 b1       	in	r24, 0x07	; 7
 584:	80 66       	ori	r24, 0x60	; 96
 586:	87 b9       	out	0x07, r24	; 7
	
	//Initialize I2C bit rate to 100kHz with pre-scalar of 0
	TWSR = 0;
 588:	10 92 b9 00 	sts	0x00B9, r1
	TWBR = ((F_CPU/F_SCL)-16)/2;
 58c:	88 e4       	ldi	r24, 0x48	; 72
 58e:	80 93 b8 00 	sts	0x00B8, r24
 592:	08 95       	ret

00000594 <I2C_Start>:
Function that sends TWI Start Bit
*************************************************/

void I2C_Start(){
	//send Start condition
	TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
 594:	84 ea       	ldi	r24, 0xA4	; 164
 596:	80 93 bc 00 	sts	0x00BC, r24
	//Wait for TWINT flag
	while(!(TWCR & _BV(TWINT)));
 59a:	ec eb       	ldi	r30, 0xBC	; 188
 59c:	f0 e0       	ldi	r31, 0x00	; 0
 59e:	80 81       	ld	r24, Z
 5a0:	88 23       	and	r24, r24
 5a2:	ec f7       	brge	.-6      	; 0x59e <I2C_Start+0xa>
}
 5a4:	08 95       	ret

000005a6 <I2C_Addr>:
Function that takes in and sends slave address and R/W bit
*************************************************/

void I2C_Addr(uint8_t address, uint8_t read_write){
	//Put SLA+R/W byte into TWDR
	TWDR = address << 1 | read_write;
 5a6:	88 0f       	add	r24, r24
 5a8:	68 2b       	or	r22, r24
 5aa:	60 93 bb 00 	sts	0x00BB, r22
	//Send Message
	TWCR = _BV(TWINT) | _BV(TWEN);
 5ae:	84 e8       	ldi	r24, 0x84	; 132
 5b0:	80 93 bc 00 	sts	0x00BC, r24
	//Wait for ack
	while(!(TWCR & _BV(TWINT)));
 5b4:	ec eb       	ldi	r30, 0xBC	; 188
 5b6:	f0 e0       	ldi	r31, 0x00	; 0
 5b8:	80 81       	ld	r24, Z
 5ba:	88 23       	and	r24, r24
 5bc:	ec f7       	brge	.-6      	; 0x5b8 <I2C_Addr+0x12>
}
 5be:	08 95       	ret

000005c0 <I2C_Write>:
Function that takes in and sends a data byte to the slave
*************************************************/

void I2C_Write(uint8_t data){
	//put data to be written in TWDR
	TWDR = data;
 5c0:	80 93 bb 00 	sts	0x00BB, r24
	//Write data to slave
	TWCR = _BV(TWINT) | _BV(TWEN);
 5c4:	84 e8       	ldi	r24, 0x84	; 132
 5c6:	80 93 bc 00 	sts	0x00BC, r24
	//wait for ack
	while(!(TWCR &_BV(TWINT)));
 5ca:	ec eb       	ldi	r30, 0xBC	; 188
 5cc:	f0 e0       	ldi	r31, 0x00	; 0
 5ce:	80 81       	ld	r24, Z
 5d0:	88 23       	and	r24, r24
 5d2:	ec f7       	brge	.-6      	; 0x5ce <I2C_Write+0xe>
}
 5d4:	08 95       	ret

000005d6 <I2C_Read>:
sent from the slave
*************************************************/

uint8_t I2C_Read(void){
	//Enable nack
	TWCR = _BV(TWINT) | _BV(TWEN);
 5d6:	84 e8       	ldi	r24, 0x84	; 132
 5d8:	80 93 bc 00 	sts	0x00BC, r24
	//wait for TWINT to indicate BYTE received from slave
	while(!(TWCR & _BV(TWINT)));
 5dc:	ec eb       	ldi	r30, 0xBC	; 188
 5de:	f0 e0       	ldi	r31, 0x00	; 0
 5e0:	80 81       	ld	r24, Z
 5e2:	88 23       	and	r24, r24
 5e4:	ec f7       	brge	.-6      	; 0x5e0 <I2C_Read+0xa>
	//return byte
	return (TWDR);
 5e6:	80 91 bb 00 	lds	r24, 0x00BB
}
 5ea:	08 95       	ret

000005ec <I2C_SendMessage>:
Function that takes in the slave address, the device memory address that
you want to write to as well as the data you want to write and sends
it over I2C to the slave
*************************************************/

void I2C_SendMessage(uint8_t slave_addr, uint8_t device_reg, uint8_t data){
 5ec:	cf 93       	push	r28
 5ee:	df 93       	push	r29
 5f0:	d6 2f       	mov	r29, r22
 5f2:	c4 2f       	mov	r28, r20
	//start communication
	I2C_Start();
 5f4:	0e 94 ca 02 	call	0x594	; 0x594 <I2C_Start>
	//address slave in write mode
	I2C_Addr(RTC_ADDRESS, WRITE);
 5f8:	60 e0       	ldi	r22, 0x00	; 0
 5fa:	88 e6       	ldi	r24, 0x68	; 104
 5fc:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <I2C_Addr>
	//specify device register to put data in
	I2C_Write(device_reg);
 600:	8d 2f       	mov	r24, r29
 602:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <I2C_Write>
	//send data byte
	I2C_Write(data);
 606:	8c 2f       	mov	r24, r28
 608:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <I2C_Write>
Function that Stops I2C communication
*************************************************/

void I2C_Stop(void){
	//Send stop condition
	TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
 60c:	84 e9       	ldi	r24, 0x94	; 148
 60e:	80 93 bc 00 	sts	0x00BC, r24
	I2C_Write(device_reg);
	//send data byte
	I2C_Write(data);
	//stop communication
	I2C_Stop();
}
 612:	df 91       	pop	r29
 614:	cf 91       	pop	r28
 616:	08 95       	ret

00000618 <I2C_RecieveMessage>:
Function that takes in a device memory address that you want
to read from and reads the data at that address and then
returns the data byte that was read
*************************************************/

uint8_t I2C_RecieveMessage(uint8_t slave_addr, uint8_t device_reg){
 618:	cf 93       	push	r28
 61a:	c6 2f       	mov	r28, r22
	//variable to store received data in
	uint8_t read_data;
	//start communication
	I2C_Start();
 61c:	0e 94 ca 02 	call	0x594	; 0x594 <I2C_Start>
	//address slave in write mode
	I2C_Addr(RTC_ADDRESS, WRITE);
 620:	60 e0       	ldi	r22, 0x00	; 0
 622:	88 e6       	ldi	r24, 0x68	; 104
 624:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <I2C_Addr>
	//specify device register to read from
	I2C_Write(device_reg);
 628:	8c 2f       	mov	r24, r28
 62a:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <I2C_Write>
	//start another communication
	I2C_Start();
 62e:	0e 94 ca 02 	call	0x594	; 0x594 <I2C_Start>
	//address slave in read mode
	I2C_Addr(RTC_ADDRESS, READ);
 632:	61 e0       	ldi	r22, 0x01	; 1
 634:	88 e6       	ldi	r24, 0x68	; 104
 636:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <I2C_Addr>
	//read and store data from slave
	read_data = I2C_Read();
 63a:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <I2C_Read>
Function that Stops I2C communication
*************************************************/

void I2C_Stop(void){
	//Send stop condition
	TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
 63e:	94 e9       	ldi	r25, 0x94	; 148
 640:	90 93 bc 00 	sts	0x00BC, r25
	read_data = I2C_Read();
	//stop communication
	I2C_Stop();
	//return byte
	return (read_data);
 644:	cf 91       	pop	r28
 646:	08 95       	ret

00000648 <LCD_SPI_initialize>:
Return value : None.
--------------------------------------------------------------------------------------------------*/
void LCD_SPI_initialize()
{
	// Set data direction for LCD output control pins
	LCD_DD_RESET  |= _BV(LCD_RESET_PIN);
 648:	20 9a       	sbi	0x04, 0	; 4
	LCD_DD_SCK    |= _BV(LCD_SCK);
 64a:	25 9a       	sbi	0x04, 5	; 4
	LCD_DD_MOSI   |= _BV(LCD_MOSI);     
 64c:	23 9a       	sbi	0x04, 3	; 4
	LCD_DD_D_OR_C |= _BV(LCD_D_OR_C);   
 64e:	54 9a       	sbi	0x0a, 4	; 10
	LCD_DD_SS     |= _BV(LCD_SS);    
 650:	22 9a       	sbi	0x04, 2	; 4
	
	// Setting SPI clock generator to Fclk/16 and enabling SPI peripheral and setting in master mode
	SPCR = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
 652:	81 e5       	ldi	r24, 0x51	; 81
 654:	8c bd       	out	0x2c, r24	; 44
 656:	08 95       	ret

00000658 <LCD_send_command>:
--------------------------------------------------------------------------------------------------*/
void LCD_send_command(BYTE command_to_send)
{
	
	// Enable LCD
	LCD_ENABLE;
 658:	2a 98       	cbi	0x05, 2	; 5
	
	// Set the LCD in command mode
	LCD_COMMAND_MODE;
 65a:	5c 98       	cbi	0x0b, 4	; 11
	
	// Writing to the SPI data register which auto. shifts out data
	SPDR = command_to_send;
 65c:	8e bd       	out	0x2e, r24	; 46
	
	// Wait while the SPIF flag is low
	while(!(SPSR & _BV(SPIF)))
 65e:	0d b4       	in	r0, 0x2d	; 45
 660:	07 fe       	sbrs	r0, 7
 662:	fd cf       	rjmp	.-6      	; 0x65e <LCD_send_command+0x6>
	{
		// Do nothing
	}
	SPSR &= ~_BV(SPIF);
 664:	8d b5       	in	r24, 0x2d	; 45
 666:	8f 77       	andi	r24, 0x7F	; 127
 668:	8d bd       	out	0x2d, r24	; 45
	
		// Disable LCD
	LCD_DISABLE;
 66a:	2a 9a       	sbi	0x05, 2	; 5
 66c:	08 95       	ret

0000066e <LCD_send_data>:
	
}
void LCD_send_data(BYTE data_to_send)
{
	// Enable LCD
	LCD_ENABLE;
 66e:	2a 98       	cbi	0x05, 2	; 5
	
	// Set Data Mode
	LCD_DATA_MODE;
 670:	5c 9a       	sbi	0x0b, 4	; 11
	
	// Store data to send in SPI data register
	SPDR = data_to_send;
 672:	8e bd       	out	0x2e, r24	; 46
	
	// Wait while the SPIF flag is low
	while(!(SPSR & _BV(SPIF)))
 674:	0d b4       	in	r0, 0x2d	; 45
 676:	07 fe       	sbrs	r0, 7
 678:	fd cf       	rjmp	.-6      	; 0x674 <LCD_send_data+0x6>
	{
		// Do nothing
	}
	
	// Disable LCD
	LCD_DISABLE;
 67a:	2a 9a       	sbi	0x05, 2	; 5
 67c:	08 95       	ret

0000067e <LCD_goto>:
	LCD_goto(0,0);
}


void LCD_goto(int column, int row)
{
 67e:	cf 93       	push	r28
 680:	c6 2f       	mov	r28, r22
	// Set the x address
	LCD_send_command(0x80 | column);
 682:	80 68       	ori	r24, 0x80	; 128
 684:	0e 94 2c 03 	call	0x658	; 0x658 <LCD_send_command>
	
	// Set the y address
	LCD_send_command(0x40 | row);
 688:	8c 2f       	mov	r24, r28
 68a:	80 64       	ori	r24, 0x40	; 64
 68c:	0e 94 2c 03 	call	0x658	; 0x658 <LCD_send_command>
}
 690:	cf 91       	pop	r28
 692:	08 95       	ret

00000694 <LCD_clear_screen>:
		LCD_send_data(pgm_read_byte(&(alarm_clock_ringing[i])));
	}
}

void LCD_clear_screen()
{
 694:	cf 93       	push	r28
 696:	df 93       	push	r29
 698:	c8 ef       	ldi	r28, 0xF8	; 248
 69a:	d1 e0       	ldi	r29, 0x01	; 1
	int i;
	
	for(i = 0; i < 504; i++)
	{
		LCD_send_data(0x00);
 69c:	80 e0       	ldi	r24, 0x00	; 0
 69e:	0e 94 37 03 	call	0x66e	; 0x66e <LCD_send_data>
 6a2:	21 97       	sbiw	r28, 0x01	; 1

void LCD_clear_screen()
{
	int i;
	
	for(i = 0; i < 504; i++)
 6a4:	20 97       	sbiw	r28, 0x00	; 0
 6a6:	d1 f7       	brne	.-12     	; 0x69c <LCD_clear_screen+0x8>
	{
		LCD_send_data(0x00);
	}
	
	// Return to home position
	LCD_goto(0,0);
 6a8:	60 e0       	ldi	r22, 0x00	; 0
 6aa:	70 e0       	ldi	r23, 0x00	; 0
 6ac:	80 e0       	ldi	r24, 0x00	; 0
 6ae:	90 e0       	ldi	r25, 0x00	; 0
 6b0:	0e 94 3f 03 	call	0x67e	; 0x67e <LCD_goto>
}
 6b4:	df 91       	pop	r29
 6b6:	cf 91       	pop	r28
 6b8:	08 95       	ret

000006ba <LCD_initialize>:
Return value : None.
--------------------------------------------------------------------------------------------------*/
void LCD_initialize()
{
	// Enabling the LCD
	LCD_ENABLE;
 6ba:	2a 98       	cbi	0x05, 2	; 5
	
	// Set the reset pin (active low) (resetting) 
	LCD_RESET;
 6bc:	28 98       	cbi	0x05, 0	; 5
	
	// Wait for 1 ms
	hw_delay(1);
 6be:	81 e0       	ldi	r24, 0x01	; 1
 6c0:	90 e0       	ldi	r25, 0x00	; 0
 6c2:	0e 94 ee 05 	call	0xbdc	; 0xbdc <hw_delay>
	
	// Set reset pin (active low) (setting)
	LCD_NRESET;
 6c6:	28 9a       	sbi	0x05, 0	; 5
	
	// Clear the screen
	LCD_clear_screen();
 6c8:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_clear_screen>
	
	// Disable the LCD 
	LCD_DISABLE;
 6cc:	2a 9a       	sbi	0x05, 2	; 5
	 *				Setting operation voltage to approx. 7V with Vop = 65
	 *				Mux 1:48
	 */
	
	// Set the display to normal mode
	LCD_send_command(0x0C);
 6ce:	8c e0       	ldi	r24, 0x0C	; 12
 6d0:	0e 94 2c 03 	call	0x658	; 0x658 <LCD_send_command>
	
	// Set the cursor to (0,0)
	LCD_goto(0,0);
 6d4:	60 e0       	ldi	r22, 0x00	; 0
 6d6:	70 e0       	ldi	r23, 0x00	; 0
 6d8:	80 e0       	ldi	r24, 0x00	; 0
 6da:	90 e0       	ldi	r25, 0x00	; 0
 6dc:	0e 94 3f 03 	call	0x67e	; 0x67e <LCD_goto>
	
	// Set LCD in Horizontal addressing mode / Extended instruction mode / Power down disabled mode
	LCD_send_command(0x21);
 6e0:	81 e2       	ldi	r24, 0x21	; 33
 6e2:	0e 94 2c 03 	call	0x658	; 0x658 <LCD_send_command>
	
	// Set the temperature coefficient to 2 (17 mV/K)
	LCD_send_command(0x06);
 6e6:	86 e0       	ldi	r24, 0x06	; 6
 6e8:	0e 94 2c 03 	call	0x658	; 0x658 <LCD_send_command>
	
	// Set operation voltage to approximately 7V
	LCD_send_command(0xA0);
 6ec:	80 ea       	ldi	r24, 0xA0	; 160
 6ee:	0e 94 2c 03 	call	0x658	; 0x658 <LCD_send_command>
	
	// Set mux rate 1:48
	LCD_send_command(0x16);
 6f2:	86 e1       	ldi	r24, 0x16	; 22
 6f4:	0e 94 2c 03 	call	0x658	; 0x658 <LCD_send_command>
	
	// Set back into normal instruction mode
	LCD_send_command(0x20);
 6f8:	80 e2       	ldi	r24, 0x20	; 32
 6fa:	0e 94 2c 03 	call	0x658	; 0x658 <LCD_send_command>
 6fe:	08 95       	ret

00000700 <LCD_print_char>:
	// Set the y address
	LCD_send_command(0x40 | row);
}

void LCD_print_char(unsigned char char_to_print)
{
 700:	0f 93       	push	r16
 702:	1f 93       	push	r17
 704:	cf 93       	push	r28
 706:	df 93       	push	r29
	unsigned char j;
	
	for(j=0; j<5; j++)
	{
		LCD_send_data((pgm_read_byte(&(smallFont [(char_to_print-32)*5 + j])) ));
 708:	08 2f       	mov	r16, r24
 70a:	10 e0       	ldi	r17, 0x00	; 0
 70c:	00 52       	subi	r16, 0x20	; 32
 70e:	11 09       	sbc	r17, r1
 710:	c8 01       	movw	r24, r16
 712:	88 0f       	add	r24, r24
 714:	99 1f       	adc	r25, r25
 716:	88 0f       	add	r24, r24
 718:	99 1f       	adc	r25, r25
 71a:	08 0f       	add	r16, r24
 71c:	19 1f       	adc	r17, r25
 71e:	c0 e0       	ldi	r28, 0x00	; 0
 720:	d0 e0       	ldi	r29, 0x00	; 0
 722:	06 56       	subi	r16, 0x66	; 102
 724:	1f 4f       	sbci	r17, 0xFF	; 255
 726:	f8 01       	movw	r30, r16
 728:	ec 0f       	add	r30, r28
 72a:	fd 1f       	adc	r31, r29
 72c:	84 91       	lpm	r24, Z
 72e:	0e 94 37 03 	call	0x66e	; 0x66e <LCD_send_data>
 732:	21 96       	adiw	r28, 0x01	; 1

void LCD_print_char(unsigned char char_to_print)
{
	unsigned char j;
	
	for(j=0; j<5; j++)
 734:	c5 30       	cpi	r28, 0x05	; 5
 736:	d1 05       	cpc	r29, r1
 738:	b1 f7       	brne	.-20     	; 0x726 <LCD_print_char+0x26>
	{
		LCD_send_data((pgm_read_byte(&(smallFont [(char_to_print-32)*5 + j])) ));
	}
}
 73a:	df 91       	pop	r29
 73c:	cf 91       	pop	r28
 73e:	1f 91       	pop	r17
 740:	0f 91       	pop	r16
 742:	08 95       	ret

00000744 <LCD_print_double_number>:
		LCD_send_data((pgm_read_byte(&(single_numbers [5*single_digit_to_print + j]))));
	}
}

void LCD_print_double_number(int number_to_print)
{
 744:	8f 92       	push	r8
 746:	9f 92       	push	r9
 748:	af 92       	push	r10
 74a:	bf 92       	push	r11
 74c:	cf 92       	push	r12
 74e:	df 92       	push	r13
 750:	ef 92       	push	r14
 752:	ff 92       	push	r15
 754:	0f 93       	push	r16
 756:	1f 93       	push	r17
 758:	cf 93       	push	r28
 75a:	df 93       	push	r29
 75c:	4c 01       	movw	r8, r24
	unsigned char j;
	int temp;
	
	temp = number_to_print / 10;
 75e:	6a e0       	ldi	r22, 0x0A	; 10
 760:	70 e0       	ldi	r23, 0x00	; 0
 762:	0e 94 01 06 	call	0xc02	; 0xc02 <__divmodhi4>
 766:	5b 01       	movw	r10, r22
	
	for(j=0; j<5; j++)
	{
		LCD_send_data((pgm_read_byte(&(single_numbers [5*temp + j]))));
 768:	6b 01       	movw	r12, r22
 76a:	cc 0c       	add	r12, r12
 76c:	dd 1c       	adc	r13, r13
 76e:	cc 0c       	add	r12, r12
 770:	dd 1c       	adc	r13, r13
 772:	c6 01       	movw	r24, r12
 774:	86 0f       	add	r24, r22
 776:	97 1f       	adc	r25, r23
 778:	c0 e0       	ldi	r28, 0x00	; 0
 77a:	d0 e0       	ldi	r29, 0x00	; 0
 77c:	0f 2e       	mov	r0, r31
 77e:	f8 e6       	ldi	r31, 0x68	; 104
 780:	ef 2e       	mov	r14, r31
 782:	f0 e0       	ldi	r31, 0x00	; 0
 784:	ff 2e       	mov	r15, r31
 786:	f0 2d       	mov	r31, r0
 788:	9c 01       	movw	r18, r24
 78a:	28 59       	subi	r18, 0x98	; 152
 78c:	3f 4f       	sbci	r19, 0xFF	; 255
 78e:	69 01       	movw	r12, r18
 790:	87 01       	movw	r16, r14
 792:	f6 01       	movw	r30, r12
 794:	ec 0f       	add	r30, r28
 796:	fd 1f       	adc	r31, r29
 798:	84 91       	lpm	r24, Z
 79a:	0e 94 37 03 	call	0x66e	; 0x66e <LCD_send_data>
 79e:	21 96       	adiw	r28, 0x01	; 1
	unsigned char j;
	int temp;
	
	temp = number_to_print / 10;
	
	for(j=0; j<5; j++)
 7a0:	c5 30       	cpi	r28, 0x05	; 5
 7a2:	d1 05       	cpc	r29, r1
 7a4:	a9 f7       	brne	.-22     	; 0x790 <LCD_print_double_number+0x4c>
	{
		LCD_send_data((pgm_read_byte(&(single_numbers [5*temp + j]))));
	}
	
	temp = number_to_print - temp*10;
 7a6:	26 ef       	ldi	r18, 0xF6	; 246
 7a8:	a5 01       	movw	r20, r10
 7aa:	24 03       	mulsu	r18, r20
 7ac:	c0 01       	movw	r24, r0
 7ae:	25 9f       	mul	r18, r21
 7b0:	90 0d       	add	r25, r0
 7b2:	11 24       	eor	r1, r1
 7b4:	88 0e       	add	r8, r24
 7b6:	99 1e       	adc	r9, r25
	
	for(j=0; j<5; j++)
	{
		LCD_send_data((pgm_read_byte(&(single_numbers [5*temp + j]))));
 7b8:	c4 01       	movw	r24, r8
 7ba:	88 0f       	add	r24, r24
 7bc:	99 1f       	adc	r25, r25
 7be:	88 0f       	add	r24, r24
 7c0:	99 1f       	adc	r25, r25
 7c2:	88 0e       	add	r8, r24
 7c4:	99 1e       	adc	r9, r25
 7c6:	c0 e0       	ldi	r28, 0x00	; 0
 7c8:	d0 e0       	ldi	r29, 0x00	; 0
 7ca:	08 0d       	add	r16, r8
 7cc:	19 1d       	adc	r17, r9
 7ce:	f8 01       	movw	r30, r16
 7d0:	ec 0f       	add	r30, r28
 7d2:	fd 1f       	adc	r31, r29
 7d4:	84 91       	lpm	r24, Z
 7d6:	0e 94 37 03 	call	0x66e	; 0x66e <LCD_send_data>
 7da:	21 96       	adiw	r28, 0x01	; 1
		LCD_send_data((pgm_read_byte(&(single_numbers [5*temp + j]))));
	}
	
	temp = number_to_print - temp*10;
	
	for(j=0; j<5; j++)
 7dc:	c5 30       	cpi	r28, 0x05	; 5
 7de:	d1 05       	cpc	r29, r1
 7e0:	b1 f7       	brne	.-20     	; 0x7ce <LCD_print_double_number+0x8a>
	{
		LCD_send_data((pgm_read_byte(&(single_numbers [5*temp + j]))));
	}
	
}
 7e2:	df 91       	pop	r29
 7e4:	cf 91       	pop	r28
 7e6:	1f 91       	pop	r17
 7e8:	0f 91       	pop	r16
 7ea:	ff 90       	pop	r15
 7ec:	ef 90       	pop	r14
 7ee:	df 90       	pop	r13
 7f0:	cf 90       	pop	r12
 7f2:	bf 90       	pop	r11
 7f4:	af 90       	pop	r10
 7f6:	9f 90       	pop	r9
 7f8:	8f 90       	pop	r8
 7fa:	08 95       	ret

000007fc <LCD_print_string>:
void LCD_print_string(const char *string)
{
 7fc:	cf 93       	push	r28
 7fe:	df 93       	push	r29
 800:	ec 01       	movw	r28, r24
	// Prints character of current index of string until string ends
	while ( *string )
 802:	88 81       	ld	r24, Y
 804:	88 23       	and	r24, r24
 806:	31 f0       	breq	.+12     	; 0x814 <LCD_print_string+0x18>
 808:	21 96       	adiw	r28, 0x01	; 1
	{
		// Prints character of current index of string
		LCD_print_char( *string++ );
 80a:	0e 94 80 03 	call	0x700	; 0x700 <LCD_print_char>
	
}
void LCD_print_string(const char *string)
{
	// Prints character of current index of string until string ends
	while ( *string )
 80e:	89 91       	ld	r24, Y+
 810:	81 11       	cpse	r24, r1
 812:	fb cf       	rjmp	.-10     	; 0x80a <LCD_print_string+0xe>
	{
		// Prints character of current index of string
		LCD_print_char( *string++ );
	}
}
 814:	df 91       	pop	r29
 816:	cf 91       	pop	r28
 818:	08 95       	ret

0000081a <LCD_print_bottom_menu>:
	LCD_send_command(0x40 | y_to_set);
}


void LCD_print_bottom_menu(const char *button1, const char *button2, const char *button3)
{
 81a:	cf 92       	push	r12
 81c:	df 92       	push	r13
 81e:	ef 92       	push	r14
 820:	ff 92       	push	r15
 822:	0f 93       	push	r16
 824:	1f 93       	push	r17
 826:	cf 93       	push	r28
 828:	df 93       	push	r29
 82a:	ec 01       	movw	r28, r24
 82c:	6b 01       	movw	r12, r22
 82e:	7a 01       	movw	r14, r20
	int tot_string_length, temp_calc, max_space, i;
	
	//Finding total number of characters
	tot_string_length = strlen(button1) + strlen(button2) + strlen(button3);
 830:	dc 01       	movw	r26, r24
 832:	0d 90       	ld	r0, X+
 834:	00 20       	and	r0, r0
 836:	e9 f7       	brne	.-6      	; 0x832 <LCD_print_bottom_menu+0x18>
 838:	11 97       	sbiw	r26, 0x01	; 1
 83a:	cd 01       	movw	r24, r26
 83c:	8c 1b       	sub	r24, r28
 83e:	9d 0b       	sbc	r25, r29
 840:	db 01       	movw	r26, r22
 842:	0d 90       	ld	r0, X+
 844:	00 20       	and	r0, r0
 846:	e9 f7       	brne	.-6      	; 0x842 <LCD_print_bottom_menu+0x28>
 848:	11 97       	sbiw	r26, 0x01	; 1
 84a:	a6 1b       	sub	r26, r22
 84c:	b7 0b       	sbc	r27, r23
 84e:	fa 01       	movw	r30, r20
 850:	01 90       	ld	r0, Z+
 852:	00 20       	and	r0, r0
 854:	e9 f7       	brne	.-6      	; 0x850 <LCD_print_bottom_menu+0x36>
 856:	31 97       	sbiw	r30, 0x01	; 1
 858:	e4 1b       	sub	r30, r20
 85a:	f5 0b       	sbc	r31, r21
 85c:	a8 0f       	add	r26, r24
 85e:	b9 1f       	adc	r27, r25
 860:	ea 0f       	add	r30, r26
 862:	fb 1f       	adc	r31, r27
	
	temp_calc = 16 - (tot_string_length);
 864:	80 e1       	ldi	r24, 0x10	; 16
 866:	90 e0       	ldi	r25, 0x00	; 0
 868:	8e 1b       	sub	r24, r30
 86a:	9f 0b       	sbc	r25, r31
	
	max_space = temp_calc / 2;
 86c:	8c 01       	movw	r16, r24
 86e:	12 f4       	brpl	.+4      	; 0x874 <LCD_print_bottom_menu+0x5a>
 870:	0f 5f       	subi	r16, 0xFF	; 255
 872:	1f 4f       	sbci	r17, 0xFF	; 255
 874:	15 95       	asr	r17
 876:	07 95       	ror	r16
	
	// Set cursor to bottom left
	LCD_goto(0,5);
 878:	65 e0       	ldi	r22, 0x05	; 5
 87a:	70 e0       	ldi	r23, 0x00	; 0
 87c:	80 e0       	ldi	r24, 0x00	; 0
 87e:	90 e0       	ldi	r25, 0x00	; 0
 880:	0e 94 3f 03 	call	0x67e	; 0x67e <LCD_goto>
	
	// print first button command heading
	LCD_print_string(button1);
 884:	ce 01       	movw	r24, r28
 886:	0e 94 fe 03 	call	0x7fc	; 0x7fc <LCD_print_string>
	
	for(i = 0; i < max_space; i++)
 88a:	10 16       	cp	r1, r16
 88c:	11 06       	cpc	r1, r17
 88e:	dc f4       	brge	.+54     	; 0x8c6 <LCD_print_bottom_menu+0xac>
 890:	c0 e0       	ldi	r28, 0x00	; 0
 892:	d0 e0       	ldi	r29, 0x00	; 0
	{
		// print a space after the first command
		LCD_print_char(' ');
 894:	80 e2       	ldi	r24, 0x20	; 32
 896:	0e 94 80 03 	call	0x700	; 0x700 <LCD_print_char>
	LCD_goto(0,5);
	
	// print first button command heading
	LCD_print_string(button1);
	
	for(i = 0; i < max_space; i++)
 89a:	21 96       	adiw	r28, 0x01	; 1
 89c:	c0 17       	cp	r28, r16
 89e:	d1 07       	cpc	r29, r17
 8a0:	c9 f7       	brne	.-14     	; 0x894 <LCD_print_bottom_menu+0x7a>
 8a2:	0b c0       	rjmp	.+22     	; 0x8ba <LCD_print_bottom_menu+0xa0>
	LCD_print_string(button2);
	
	for(i = 0; i < max_space; i++)
	{
		// print a space after the first command
		LCD_print_char(' ');
 8a4:	80 e2       	ldi	r24, 0x20	; 32
 8a6:	0e 94 80 03 	call	0x700	; 0x700 <LCD_print_char>
	}
	
	// print second button command heading
	LCD_print_string(button2);
	
	for(i = 0; i < max_space; i++)
 8aa:	21 96       	adiw	r28, 0x01	; 1
 8ac:	c0 17       	cp	r28, r16
 8ae:	d1 07       	cpc	r29, r17
 8b0:	c9 f7       	brne	.-14     	; 0x8a4 <LCD_print_bottom_menu+0x8a>
	{
		// print a space after the first command
		LCD_print_char(' ');
	}
	// print third button command heading
	LCD_print_string(button3);
 8b2:	c7 01       	movw	r24, r14
 8b4:	0e 94 fe 03 	call	0x7fc	; 0x7fc <LCD_print_string>
 8b8:	0a c0       	rjmp	.+20     	; 0x8ce <LCD_print_bottom_menu+0xb4>
		// print a space after the first command
		LCD_print_char(' ');
	}
	
	// print second button command heading
	LCD_print_string(button2);
 8ba:	c6 01       	movw	r24, r12
 8bc:	0e 94 fe 03 	call	0x7fc	; 0x7fc <LCD_print_string>
	
	for(i = 0; i < max_space; i++)
 8c0:	c0 e0       	ldi	r28, 0x00	; 0
 8c2:	d0 e0       	ldi	r29, 0x00	; 0
 8c4:	ef cf       	rjmp	.-34     	; 0x8a4 <LCD_print_bottom_menu+0x8a>
		// print a space after the first command
		LCD_print_char(' ');
	}
	
	// print second button command heading
	LCD_print_string(button2);
 8c6:	c6 01       	movw	r24, r12
 8c8:	0e 94 fe 03 	call	0x7fc	; 0x7fc <LCD_print_string>
 8cc:	f2 cf       	rjmp	.-28     	; 0x8b2 <LCD_print_bottom_menu+0x98>
		// print a space after the first command
		LCD_print_char(' ');
	}
	// print third button command heading
	LCD_print_string(button3);
}
 8ce:	df 91       	pop	r29
 8d0:	cf 91       	pop	r28
 8d2:	1f 91       	pop	r17
 8d4:	0f 91       	pop	r16
 8d6:	ff 90       	pop	r15
 8d8:	ef 90       	pop	r14
 8da:	df 90       	pop	r13
 8dc:	cf 90       	pop	r12
 8de:	08 95       	ret

000008e0 <LCD_print_time_display>:
	}
	array_to_shift[string_length - 1] = temp_var;
}

void LCD_print_time_display(time_t current_time, int current_temperature, char *button1, char *button2, char *button3 )
{
 8e0:	af 92       	push	r10
 8e2:	bf 92       	push	r11
 8e4:	cf 92       	push	r12
 8e6:	df 92       	push	r13
 8e8:	ef 92       	push	r14
 8ea:	ff 92       	push	r15
 8ec:	0f 93       	push	r16
 8ee:	1f 93       	push	r17
 8f0:	cf 93       	push	r28
 8f2:	df 93       	push	r29
 8f4:	cd b7       	in	r28, 0x3d	; 61
 8f6:	de b7       	in	r29, 0x3e	; 62
 8f8:	28 97       	sbiw	r28, 0x08	; 8
 8fa:	0f b6       	in	r0, 0x3f	; 63
 8fc:	f8 94       	cli
 8fe:	de bf       	out	0x3e, r29	; 62
 900:	0f be       	out	0x3f, r0	; 63
 902:	cd bf       	out	0x3d, r28	; 61
 904:	29 83       	std	Y+1, r18	; 0x01
 906:	3a 83       	std	Y+2, r19	; 0x02
 908:	4b 83       	std	Y+3, r20	; 0x03
 90a:	6d 83       	std	Y+5, r22	; 0x05
 90c:	7e 83       	std	Y+6, r23	; 0x06
 90e:	8f 83       	std	Y+7, r24	; 0x07
 910:	98 87       	std	Y+8, r25	; 0x08
	// Example of Time display
	// Printing time portion
	LCD_goto(0,0);
 912:	60 e0       	ldi	r22, 0x00	; 0
 914:	70 e0       	ldi	r23, 0x00	; 0
 916:	80 e0       	ldi	r24, 0x00	; 0
 918:	90 e0       	ldi	r25, 0x00	; 0
 91a:	0e 94 3f 03 	call	0x67e	; 0x67e <LCD_goto>
	LCD_print_double_number(current_time.hour);
 91e:	8d 81       	ldd	r24, Y+5	; 0x05
 920:	90 e0       	ldi	r25, 0x00	; 0
 922:	0e 94 a2 03 	call	0x744	; 0x744 <LCD_print_double_number>
	LCD_print_char(':');
 926:	8a e3       	ldi	r24, 0x3A	; 58
 928:	0e 94 80 03 	call	0x700	; 0x700 <LCD_print_char>
	LCD_print_double_number(current_time.minute);
 92c:	8e 81       	ldd	r24, Y+6	; 0x06
 92e:	90 e0       	ldi	r25, 0x00	; 0
 930:	0e 94 a2 03 	call	0x744	; 0x744 <LCD_print_double_number>
	LCD_print_char(':');
 934:	8a e3       	ldi	r24, 0x3A	; 58
 936:	0e 94 80 03 	call	0x700	; 0x700 <LCD_print_char>
	LCD_print_double_number(current_time.second);
 93a:	8f 81       	ldd	r24, Y+7	; 0x07
 93c:	90 e0       	ldi	r25, 0x00	; 0
 93e:	0e 94 a2 03 	call	0x744	; 0x744 <LCD_print_double_number>
	LCD_print_char(' ');
 942:	80 e2       	ldi	r24, 0x20	; 32
 944:	0e 94 80 03 	call	0x700	; 0x700 <LCD_print_char>
	if(current_time.AM_PM)
 948:	88 85       	ldd	r24, Y+8	; 0x08
 94a:	88 23       	and	r24, r24
 94c:	29 f0       	breq	.+10     	; 0x958 <__stack+0x59>
	{
		LCD_print_string("PM");
 94e:	85 e2       	ldi	r24, 0x25	; 37
 950:	91 e0       	ldi	r25, 0x01	; 1
 952:	0e 94 fe 03 	call	0x7fc	; 0x7fc <LCD_print_string>
 956:	04 c0       	rjmp	.+8      	; 0x960 <__stack+0x61>
	}
	else
	{
		LCD_print_string("AM");
 958:	88 e2       	ldi	r24, 0x28	; 40
 95a:	91 e0       	ldi	r25, 0x01	; 1
 95c:	0e 94 fe 03 	call	0x7fc	; 0x7fc <LCD_print_string>
	}
	
	// Printing date portion
	LCD_goto(0,2);
 960:	62 e0       	ldi	r22, 0x02	; 2
 962:	70 e0       	ldi	r23, 0x00	; 0
 964:	80 e0       	ldi	r24, 0x00	; 0
 966:	90 e0       	ldi	r25, 0x00	; 0
 968:	0e 94 3f 03 	call	0x67e	; 0x67e <LCD_goto>
	LCD_print_double_number(current_time.month);
 96c:	8a 81       	ldd	r24, Y+2	; 0x02
 96e:	90 e0       	ldi	r25, 0x00	; 0
 970:	0e 94 a2 03 	call	0x744	; 0x744 <LCD_print_double_number>
	LCD_print_char('/');
 974:	8f e2       	ldi	r24, 0x2F	; 47
 976:	0e 94 80 03 	call	0x700	; 0x700 <LCD_print_char>
	LCD_print_double_number(current_time.day);
 97a:	8b 81       	ldd	r24, Y+3	; 0x03
 97c:	90 e0       	ldi	r25, 0x00	; 0
 97e:	0e 94 a2 03 	call	0x744	; 0x744 <LCD_print_double_number>
	LCD_print_char('/');
 982:	8f e2       	ldi	r24, 0x2F	; 47
 984:	0e 94 80 03 	call	0x700	; 0x700 <LCD_print_char>
	LCD_print_double_number(current_time.year);
 988:	89 81       	ldd	r24, Y+1	; 0x01
 98a:	90 e0       	ldi	r25, 0x00	; 0
 98c:	0e 94 a2 03 	call	0x744	; 0x744 <LCD_print_double_number>
	
	// Printing Temperature portion
	LCD_goto(64,1);
 990:	61 e0       	ldi	r22, 0x01	; 1
 992:	70 e0       	ldi	r23, 0x00	; 0
 994:	80 e4       	ldi	r24, 0x40	; 64
 996:	90 e0       	ldi	r25, 0x00	; 0
 998:	0e 94 3f 03 	call	0x67e	; 0x67e <LCD_goto>
	LCD_print_double_number(current_temperature);
 99c:	c8 01       	movw	r24, r16
 99e:	0e 94 a2 03 	call	0x744	; 0x744 <LCD_print_double_number>
	LCD_print_string(" C");
 9a2:	8b e2       	ldi	r24, 0x2B	; 43
 9a4:	91 e0       	ldi	r25, 0x01	; 1
 9a6:	0e 94 fe 03 	call	0x7fc	; 0x7fc <LCD_print_string>
	
	// Printing bottom menu
	LCD_print_bottom_menu(button1, button2, button3);
 9aa:	a5 01       	movw	r20, r10
 9ac:	b6 01       	movw	r22, r12
 9ae:	c7 01       	movw	r24, r14
 9b0:	0e 94 0d 04 	call	0x81a	; 0x81a <LCD_print_bottom_menu>
}
 9b4:	28 96       	adiw	r28, 0x08	; 8
 9b6:	0f b6       	in	r0, 0x3f	; 63
 9b8:	f8 94       	cli
 9ba:	de bf       	out	0x3e, r29	; 62
 9bc:	0f be       	out	0x3f, r0	; 63
 9be:	cd bf       	out	0x3d, r28	; 61
 9c0:	df 91       	pop	r29
 9c2:	cf 91       	pop	r28
 9c4:	1f 91       	pop	r17
 9c6:	0f 91       	pop	r16
 9c8:	ff 90       	pop	r15
 9ca:	ef 90       	pop	r14
 9cc:	df 90       	pop	r13
 9ce:	cf 90       	pop	r12
 9d0:	bf 90       	pop	r11
 9d2:	af 90       	pop	r10
 9d4:	08 95       	ret

000009d6 <LCD_print_alarm_display>:
	LCD_print_bottom_menu(button1, button2, button3);
	
}

void LCD_print_alarm_display(time_t alarmtime, const char *button1, const char *button2, const char *button3)
{
 9d6:	cf 92       	push	r12
 9d8:	df 92       	push	r13
 9da:	ef 92       	push	r14
 9dc:	ff 92       	push	r15
 9de:	0f 93       	push	r16
 9e0:	1f 93       	push	r17
 9e2:	cf 93       	push	r28
 9e4:	df 93       	push	r29
 9e6:	cd b7       	in	r28, 0x3d	; 61
 9e8:	de b7       	in	r29, 0x3e	; 62
 9ea:	28 97       	sbiw	r28, 0x08	; 8
 9ec:	0f b6       	in	r0, 0x3f	; 63
 9ee:	f8 94       	cli
 9f0:	de bf       	out	0x3e, r29	; 62
 9f2:	0f be       	out	0x3f, r0	; 63
 9f4:	cd bf       	out	0x3d, r28	; 61
 9f6:	6d 83       	std	Y+5, r22	; 0x05
 9f8:	7e 83       	std	Y+6, r23	; 0x06
	LCD_clear_screen();
 9fa:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_clear_screen>
	LCD_goto(0,0);
 9fe:	60 e0       	ldi	r22, 0x00	; 0
 a00:	70 e0       	ldi	r23, 0x00	; 0
 a02:	80 e0       	ldi	r24, 0x00	; 0
 a04:	90 e0       	ldi	r25, 0x00	; 0
 a06:	0e 94 3f 03 	call	0x67e	; 0x67e <LCD_goto>
	LCD_print_string("A1:");
 a0a:	8e e2       	ldi	r24, 0x2E	; 46
 a0c:	91 e0       	ldi	r25, 0x01	; 1
 a0e:	0e 94 fe 03 	call	0x7fc	; 0x7fc <LCD_print_string>
	LCD_print_double_number(alarmtime.hour);
 a12:	8d 81       	ldd	r24, Y+5	; 0x05
 a14:	90 e0       	ldi	r25, 0x00	; 0
 a16:	0e 94 a2 03 	call	0x744	; 0x744 <LCD_print_double_number>
	LCD_print_char(':');
 a1a:	8a e3       	ldi	r24, 0x3A	; 58
 a1c:	0e 94 80 03 	call	0x700	; 0x700 <LCD_print_char>
	LCD_print_double_number(alarmtime.minute);
 a20:	8e 81       	ldd	r24, Y+6	; 0x06
 a22:	90 e0       	ldi	r25, 0x00	; 0
 a24:	0e 94 a2 03 	call	0x744	; 0x744 <LCD_print_double_number>
	{
		LCD_print_string(" PM");
	}
	*/
	
	LCD_print_bottom_menu(button1, button2, button3);
 a28:	a6 01       	movw	r20, r12
 a2a:	b7 01       	movw	r22, r14
 a2c:	c8 01       	movw	r24, r16
 a2e:	0e 94 0d 04 	call	0x81a	; 0x81a <LCD_print_bottom_menu>
 a32:	28 96       	adiw	r28, 0x08	; 8
 a34:	0f b6       	in	r0, 0x3f	; 63
 a36:	f8 94       	cli
 a38:	de bf       	out	0x3e, r29	; 62
 a3a:	0f be       	out	0x3f, r0	; 63
 a3c:	cd bf       	out	0x3d, r28	; 61
 a3e:	df 91       	pop	r29
 a40:	cf 91       	pop	r28
 a42:	1f 91       	pop	r17
 a44:	0f 91       	pop	r16
 a46:	ff 90       	pop	r15
 a48:	ef 90       	pop	r14
 a4a:	df 90       	pop	r13
 a4c:	cf 90       	pop	r12
 a4e:	08 95       	ret

00000a50 <fromBCD>:
/*************************************************
Function that converts a binary coded decimal number to a decimal
*************************************************/

uint8_t fromBCD(uint8_t data_in){
	return ((data_in & 0x0F) + 10*((data_in>>4) & 0x07));
 a50:	98 2f       	mov	r25, r24
 a52:	96 95       	lsr	r25
 a54:	96 95       	lsr	r25
 a56:	96 95       	lsr	r25
 a58:	9e 70       	andi	r25, 0x0E	; 14
 a5a:	29 2f       	mov	r18, r25
 a5c:	22 0f       	add	r18, r18
 a5e:	22 0f       	add	r18, r18
 a60:	92 0f       	add	r25, r18
 a62:	8f 70       	andi	r24, 0x0F	; 15
}
 a64:	89 0f       	add	r24, r25
 a66:	08 95       	ret

00000a68 <toBCD>:
/*************************************************
Function that converts a decimal number to a binary coded decimal
*************************************************/

uint8_t toBCD(uint8_t data_out){
	return (((data_out/10)<<4) | (data_out % 10));
 a68:	9d ec       	ldi	r25, 0xCD	; 205
 a6a:	89 9f       	mul	r24, r25
 a6c:	91 2d       	mov	r25, r1
 a6e:	11 24       	eor	r1, r1
 a70:	96 95       	lsr	r25
 a72:	96 95       	lsr	r25
 a74:	96 95       	lsr	r25
 a76:	40 e1       	ldi	r20, 0x10	; 16
 a78:	94 9f       	mul	r25, r20
 a7a:	90 01       	movw	r18, r0
 a7c:	11 24       	eor	r1, r1
 a7e:	99 0f       	add	r25, r25
 a80:	39 2f       	mov	r19, r25
 a82:	33 0f       	add	r19, r19
 a84:	33 0f       	add	r19, r19
 a86:	93 0f       	add	r25, r19
 a88:	89 1b       	sub	r24, r25
}
 a8a:	82 2b       	or	r24, r18
 a8c:	08 95       	ret

00000a8e <RTC_Set>:
/*************************************************
Function that sets the RTC
*************************************************/

void RTC_Set(time_t times)
{
 a8e:	cf 93       	push	r28
 a90:	df 93       	push	r29
 a92:	cd b7       	in	r28, 0x3d	; 61
 a94:	de b7       	in	r29, 0x3e	; 62
 a96:	28 97       	sbiw	r28, 0x08	; 8
 a98:	0f b6       	in	r0, 0x3f	; 63
 a9a:	f8 94       	cli
 a9c:	de bf       	out	0x3e, r29	; 62
 a9e:	0f be       	out	0x3f, r0	; 63
 aa0:	cd bf       	out	0x3d, r28	; 61
 aa2:	3a 83       	std	Y+2, r19	; 0x02
 aa4:	4b 83       	std	Y+3, r20	; 0x03
 aa6:	5c 83       	std	Y+4, r21	; 0x04
 aa8:	6d 83       	std	Y+5, r22	; 0x05
 aaa:	7e 83       	std	Y+6, r23	; 0x06
 aac:	8f 83       	std	Y+7, r24	; 0x07
	I2C_SendMessage(RTC_ADDRESS, YEAR_R, toBCD(times.year));
 aae:	82 2f       	mov	r24, r18
 ab0:	0e 94 34 05 	call	0xa68	; 0xa68 <toBCD>
 ab4:	48 2f       	mov	r20, r24
 ab6:	66 e0       	ldi	r22, 0x06	; 6
 ab8:	88 e6       	ldi	r24, 0x68	; 104
 aba:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2C_SendMessage>
	I2C_SendMessage(RTC_ADDRESS, MONTH_R, toBCD(times.month));
 abe:	8a 81       	ldd	r24, Y+2	; 0x02
 ac0:	0e 94 34 05 	call	0xa68	; 0xa68 <toBCD>
 ac4:	48 2f       	mov	r20, r24
 ac6:	65 e0       	ldi	r22, 0x05	; 5
 ac8:	88 e6       	ldi	r24, 0x68	; 104
 aca:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2C_SendMessage>
	I2C_SendMessage(RTC_ADDRESS, DATE_R, toBCD(times.day));
 ace:	8b 81       	ldd	r24, Y+3	; 0x03
 ad0:	0e 94 34 05 	call	0xa68	; 0xa68 <toBCD>
 ad4:	48 2f       	mov	r20, r24
 ad6:	64 e0       	ldi	r22, 0x04	; 4
 ad8:	88 e6       	ldi	r24, 0x68	; 104
 ada:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2C_SendMessage>
	I2C_SendMessage(RTC_ADDRESS, DAY_R, toBCD(times.day_of_week));
 ade:	8c 81       	ldd	r24, Y+4	; 0x04
 ae0:	0e 94 34 05 	call	0xa68	; 0xa68 <toBCD>
 ae4:	48 2f       	mov	r20, r24
 ae6:	63 e0       	ldi	r22, 0x03	; 3
 ae8:	88 e6       	ldi	r24, 0x68	; 104
 aea:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2C_SendMessage>
	I2C_SendMessage(RTC_ADDRESS, HOURS_R, toBCD(times.hour) & ~_BV(6));
 aee:	8d 81       	ldd	r24, Y+5	; 0x05
 af0:	0e 94 34 05 	call	0xa68	; 0xa68 <toBCD>
 af4:	48 2f       	mov	r20, r24
 af6:	4f 7b       	andi	r20, 0xBF	; 191
 af8:	62 e0       	ldi	r22, 0x02	; 2
 afa:	88 e6       	ldi	r24, 0x68	; 104
 afc:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2C_SendMessage>
	I2C_SendMessage(RTC_ADDRESS, MINUTES_R, toBCD(times.minute));
 b00:	8e 81       	ldd	r24, Y+6	; 0x06
 b02:	0e 94 34 05 	call	0xa68	; 0xa68 <toBCD>
 b06:	48 2f       	mov	r20, r24
 b08:	61 e0       	ldi	r22, 0x01	; 1
 b0a:	88 e6       	ldi	r24, 0x68	; 104
 b0c:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2C_SendMessage>
	I2C_SendMessage(RTC_ADDRESS, SECONDS_R, toBCD(times.second));
 b10:	8f 81       	ldd	r24, Y+7	; 0x07
 b12:	0e 94 34 05 	call	0xa68	; 0xa68 <toBCD>
 b16:	48 2f       	mov	r20, r24
 b18:	60 e0       	ldi	r22, 0x00	; 0
 b1a:	88 e6       	ldi	r24, 0x68	; 104
 b1c:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2C_SendMessage>
	
}
 b20:	28 96       	adiw	r28, 0x08	; 8
 b22:	0f b6       	in	r0, 0x3f	; 63
 b24:	f8 94       	cli
 b26:	de bf       	out	0x3e, r29	; 62
 b28:	0f be       	out	0x3f, r0	; 63
 b2a:	cd bf       	out	0x3d, r28	; 61
 b2c:	df 91       	pop	r29
 b2e:	cf 91       	pop	r28
 b30:	08 95       	ret

00000b32 <RTC_Read>:
/*************************************************
Function that reads the  from the RTC
*************************************************/

void RTC_Read(time_t *times)
{
 b32:	cf 93       	push	r28
 b34:	df 93       	push	r29
 b36:	ec 01       	movw	r28, r24
	times->year = fromBCD(I2C_RecieveMessage(RTC_ADDRESS, YEAR_R));
 b38:	66 e0       	ldi	r22, 0x06	; 6
 b3a:	88 e6       	ldi	r24, 0x68	; 104
 b3c:	0e 94 0c 03 	call	0x618	; 0x618 <I2C_RecieveMessage>
 b40:	0e 94 28 05 	call	0xa50	; 0xa50 <fromBCD>
 b44:	88 83       	st	Y, r24
	times->month = fromBCD(I2C_RecieveMessage(RTC_ADDRESS, MONTH_R));
 b46:	65 e0       	ldi	r22, 0x05	; 5
 b48:	88 e6       	ldi	r24, 0x68	; 104
 b4a:	0e 94 0c 03 	call	0x618	; 0x618 <I2C_RecieveMessage>
 b4e:	0e 94 28 05 	call	0xa50	; 0xa50 <fromBCD>
 b52:	89 83       	std	Y+1, r24	; 0x01
	times->day = fromBCD(I2C_RecieveMessage(RTC_ADDRESS, DATE_R));
 b54:	64 e0       	ldi	r22, 0x04	; 4
 b56:	88 e6       	ldi	r24, 0x68	; 104
 b58:	0e 94 0c 03 	call	0x618	; 0x618 <I2C_RecieveMessage>
 b5c:	0e 94 28 05 	call	0xa50	; 0xa50 <fromBCD>
 b60:	8a 83       	std	Y+2, r24	; 0x02
	times->day_of_week = fromBCD(I2C_RecieveMessage(RTC_ADDRESS, DAY_R));
 b62:	63 e0       	ldi	r22, 0x03	; 3
 b64:	88 e6       	ldi	r24, 0x68	; 104
 b66:	0e 94 0c 03 	call	0x618	; 0x618 <I2C_RecieveMessage>
 b6a:	0e 94 28 05 	call	0xa50	; 0xa50 <fromBCD>
 b6e:	8b 83       	std	Y+3, r24	; 0x03
	times->hour  = fromBCD(I2C_RecieveMessage(RTC_ADDRESS, HOURS_R)) & 0x3F;
 b70:	62 e0       	ldi	r22, 0x02	; 2
 b72:	88 e6       	ldi	r24, 0x68	; 104
 b74:	0e 94 0c 03 	call	0x618	; 0x618 <I2C_RecieveMessage>
 b78:	0e 94 28 05 	call	0xa50	; 0xa50 <fromBCD>
 b7c:	8f 73       	andi	r24, 0x3F	; 63
 b7e:	8c 83       	std	Y+4, r24	; 0x04
	times->minute = fromBCD(I2C_RecieveMessage(RTC_ADDRESS, MINUTES_R));
 b80:	61 e0       	ldi	r22, 0x01	; 1
 b82:	88 e6       	ldi	r24, 0x68	; 104
 b84:	0e 94 0c 03 	call	0x618	; 0x618 <I2C_RecieveMessage>
 b88:	0e 94 28 05 	call	0xa50	; 0xa50 <fromBCD>
 b8c:	8d 83       	std	Y+5, r24	; 0x05
	times->second = fromBCD(I2C_RecieveMessage(RTC_ADDRESS, SECONDS_R));
 b8e:	60 e0       	ldi	r22, 0x00	; 0
 b90:	88 e6       	ldi	r24, 0x68	; 104
 b92:	0e 94 0c 03 	call	0x618	; 0x618 <I2C_RecieveMessage>
 b96:	0e 94 28 05 	call	0xa50	; 0xa50 <fromBCD>
 b9a:	8e 83       	std	Y+6, r24	; 0x06
	
 b9c:	df 91       	pop	r29
 b9e:	cf 91       	pop	r28
 ba0:	08 95       	ret

00000ba2 <Timer2_Init>:
 ba2:	82 e0       	ldi	r24, 0x02	; 2
 ba4:	80 93 b0 00 	sts	0x00B0, r24
 ba8:	e1 eb       	ldi	r30, 0xB1	; 177
 baa:	f0 e0       	ldi	r31, 0x00	; 0
 bac:	80 81       	ld	r24, Z
 bae:	87 60       	ori	r24, 0x07	; 7
 bb0:	80 83       	st	Z, r24
 bb2:	08 95       	ret

00000bb4 <Timer1_Init>:
 bb4:	21 9a       	sbi	0x04, 1	; 4
 bb6:	80 e8       	ldi	r24, 0x80	; 128
 bb8:	80 93 80 00 	sts	0x0080, r24
 bbc:	80 e1       	ldi	r24, 0x10	; 16
 bbe:	80 93 81 00 	sts	0x0081, r24
 bc2:	86 e8       	ldi	r24, 0x86	; 134
 bc4:	91 e0       	ldi	r25, 0x01	; 1
 bc6:	90 93 87 00 	sts	0x0087, r25
 bca:	80 93 86 00 	sts	0x0086, r24
 bce:	8a e5       	ldi	r24, 0x5A	; 90
 bd0:	90 e0       	ldi	r25, 0x00	; 0
 bd2:	90 93 89 00 	sts	0x0089, r25
 bd6:	80 93 88 00 	sts	0x0088, r24
 bda:	08 95       	ret

00000bdc <hw_delay>:
 bdc:	20 e1       	ldi	r18, 0x10	; 16
 bde:	20 93 b3 00 	sts	0x00B3, r18
 be2:	00 97       	sbiw	r24, 0x00	; 0
 be4:	69 f0       	breq	.+26     	; 0xc00 <hw_delay+0x24>
 be6:	20 e0       	ldi	r18, 0x00	; 0
 be8:	30 e0       	ldi	r19, 0x00	; 0
 bea:	e2 eb       	ldi	r30, 0xB2	; 178
 bec:	f0 e0       	ldi	r31, 0x00	; 0
 bee:	b9 9a       	sbi	0x17, 1	; 23
 bf0:	10 82       	st	Z, r1
 bf2:	b9 9b       	sbis	0x17, 1	; 23
 bf4:	fe cf       	rjmp	.-4      	; 0xbf2 <hw_delay+0x16>
 bf6:	2f 5f       	subi	r18, 0xFF	; 255
 bf8:	3f 4f       	sbci	r19, 0xFF	; 255
 bfa:	28 17       	cp	r18, r24
 bfc:	39 07       	cpc	r19, r25
 bfe:	b9 f7       	brne	.-18     	; 0xbee <hw_delay+0x12>
 c00:	08 95       	ret

00000c02 <__divmodhi4>:
 c02:	97 fb       	bst	r25, 7
 c04:	07 2e       	mov	r0, r23
 c06:	16 f4       	brtc	.+4      	; 0xc0c <__divmodhi4+0xa>
 c08:	00 94       	com	r0
 c0a:	07 d0       	rcall	.+14     	; 0xc1a <__divmodhi4_neg1>
 c0c:	77 fd       	sbrc	r23, 7
 c0e:	09 d0       	rcall	.+18     	; 0xc22 <__divmodhi4_neg2>
 c10:	0e 94 15 06 	call	0xc2a	; 0xc2a <__udivmodhi4>
 c14:	07 fc       	sbrc	r0, 7
 c16:	05 d0       	rcall	.+10     	; 0xc22 <__divmodhi4_neg2>
 c18:	3e f4       	brtc	.+14     	; 0xc28 <__divmodhi4_exit>

00000c1a <__divmodhi4_neg1>:
 c1a:	90 95       	com	r25
 c1c:	81 95       	neg	r24
 c1e:	9f 4f       	sbci	r25, 0xFF	; 255
 c20:	08 95       	ret

00000c22 <__divmodhi4_neg2>:
 c22:	70 95       	com	r23
 c24:	61 95       	neg	r22
 c26:	7f 4f       	sbci	r23, 0xFF	; 255

00000c28 <__divmodhi4_exit>:
 c28:	08 95       	ret

00000c2a <__udivmodhi4>:
 c2a:	aa 1b       	sub	r26, r26
 c2c:	bb 1b       	sub	r27, r27
 c2e:	51 e1       	ldi	r21, 0x11	; 17
 c30:	07 c0       	rjmp	.+14     	; 0xc40 <__udivmodhi4_ep>

00000c32 <__udivmodhi4_loop>:
 c32:	aa 1f       	adc	r26, r26
 c34:	bb 1f       	adc	r27, r27
 c36:	a6 17       	cp	r26, r22
 c38:	b7 07       	cpc	r27, r23
 c3a:	10 f0       	brcs	.+4      	; 0xc40 <__udivmodhi4_ep>
 c3c:	a6 1b       	sub	r26, r22
 c3e:	b7 0b       	sbc	r27, r23

00000c40 <__udivmodhi4_ep>:
 c40:	88 1f       	adc	r24, r24
 c42:	99 1f       	adc	r25, r25
 c44:	5a 95       	dec	r21
 c46:	a9 f7       	brne	.-22     	; 0xc32 <__udivmodhi4_loop>
 c48:	80 95       	com	r24
 c4a:	90 95       	com	r25
 c4c:	bc 01       	movw	r22, r24
 c4e:	cd 01       	movw	r24, r26
 c50:	08 95       	ret

00000c52 <strcpy>:
 c52:	fb 01       	movw	r30, r22
 c54:	dc 01       	movw	r26, r24
 c56:	01 90       	ld	r0, Z+
 c58:	0d 92       	st	X+, r0
 c5a:	00 20       	and	r0, r0
 c5c:	e1 f7       	brne	.-8      	; 0xc56 <strcpy+0x4>
 c5e:	08 95       	ret

00000c60 <_exit>:
 c60:	f8 94       	cli

00000c62 <__stop_program>:
 c62:	ff cf       	rjmp	.-2      	; 0xc62 <__stop_program>
